# -*- coding: utf-8 -*-
"""Alg_Num3_ZR_AŚ

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/15RpcgAwIwJC1-3sQkxBGDFyWkjeH7_k6
"""

import numpy as np

def f(x, y):
    return 2 * y**2 - 2 * x * (x**3 - 1)

def euler_method(a, n):
    h = a / n
    x = np.linspace(0, a, n+1)
    y = np.zeros(n+1)

    for i in range(n):
        y[i+1] = y[i] + h * f(x[i], y[i])

    return x, y

def midpoint_method(a, n):
    h = a / n
    x = np.linspace(0, a, n+1)
    y = np.zeros(n+1)

    for i in range(n):
        x_mid = x[i] + h / 2
        y_mid = y[i] + h / 2 * f(x[i], y[i])
        y[i+1] = y[i] + h * f(x_mid, y_mid)

    return x, y

def max_error(y_numeric, y_analytic):
    return np.max(np.abs(y_numeric - y_analytic))

def get_integer_input(message):
    while True:
        try:
            value = int(input(message))
            if value >= 1:
                return value
            else:
                print("Wprowadź liczbę naturalną większą lub równą 1.")
        except ValueError:
            print("Wprowadź liczbę naturalną.")

def get_float_input(message, min_value=1e-14):
    while True:
        try:
            value = float(input(message))
            if value > min_value:
                return value
            else:
                print(f"Wprowadź liczbę rzeczywistą większą od {min_value}.")
        except ValueError:
            print("Wprowadź liczbę rzeczywistą.")

n = get_integer_input("Podaj liczbę naturalną n (n >= 1): ")
a = get_float_input("Podaj wartość rzeczywistą a (a > 0): ")

x_analytic = np.linspace(0, a, n+1)**2
x_euler, y_euler = euler_method(a, n)
x_midpoint, y_midpoint = midpoint_method(a, n)

error_euler = max_error(y_euler, x_analytic)
error_midpoint = max_error(y_midpoint, x_analytic)

print("\nWyniki dla metody Eulera:")
for i, (xi, yi) in enumerate(zip(x_euler, y_euler), 1):
    print(f"y_{i-1}({xi:.3f}) = {yi:.5f}")

print("\nWyniki dla metody punktu środkowego:")
for i, (xi, yi) in enumerate(zip(x_midpoint, y_midpoint), 1):
    print(f"y_{i-1}({xi:.3f}) = {yi:.5f}")

print("\nWyniki dla rozwiązania dokładnego (y=x^2):")
for i, (xi, yi) in enumerate(zip(x_analytic, x_analytic**2), 1):
    print(f"y_{i-1}({xi:.3f}) = {yi:.5f}")

print(f"\nBłąd maksymalny dla metody Eulera: {error_euler}")
print(f"Błąd maksymalny dla metody punktu środkowego: {error_midpoint}")

"""kod opisany"""

import numpy as np

# Funkcja opisująca równanie różniczkowe
def f(x, y):
    return 2 * y**2 - 2 * x * (x**3 - 1)

# Metoda Eulera do rozwiązania równania różniczkowego
def euler_method(a, n):
    h = a / n
    x = np.linspace(0, a, n+1)
    y = np.zeros(n+1)

    for i in range(n):
        y[i+1] = y[i] + h * f(x[i], y[i])

    return x, y

# Metoda punktu środkowego do rozwiązania równania różniczkowego
def midpoint_method(a, n):
    h = a / n
    x = np.linspace(0, a, n+1)
    y = np.zeros(n+1)

    for i in range(n):
        x_mid = x[i] + h / 2
        y_mid = y[i] + h / 2 * f(x[i], y[i])
        y[i+1] = y[i] + h * f(x_mid, y_mid)

    return x, y

# Funkcja do obliczania błędu maksymalnego między rozwiązaniem numerycznym a analitycznym
def max_error(y_numeric, y_analytic):
    return np.max(np.abs(y_numeric - y_analytic))

# Funkcja do pobierania liczby całkowitej od użytkownika
def get_integer_input(message):
    while True:
        try:
            value = int(input(message))
            if value >= 1:
                return value
            else:
                print("Wprowadź liczbę naturalną większą lub równą 1.")
        except ValueError:
            print("Wprowadź liczbę naturalną.")

# Funkcja do pobierania liczby rzeczywistej od użytkownika z opcjonalnym minimalnym limitem
def get_float_input(message, min_value=1e-14):
    while True:
        try:
            value = float(input(message))
            if value > min_value:
                return value
            else:
                print(f"Wprowadź liczbę rzeczywistą większą od {min_value}.")
        except ValueError:
            print("Wprowadź liczbę rzeczywistą.")

# Pobranie danych od użytkownika
n = get_integer_input("Podaj liczbę naturalną n (n >= 1): ")
a = get_float_input("Podaj wartość rzeczywistą a (a > 0): ")

# Obliczenia dla metody Eulera
x_analytic = np.linspace(0, a, n+1)**2
x_euler, y_euler = euler_method(a, n)
error_euler = max_error(y_euler, x_analytic)

# Obliczenia dla metody punktu środkowego
x_midpoint, y_midpoint = midpoint_method(a, n)
error_midpoint = max_error(y_midpoint, x_analytic)

# Wyświetlanie wyników
print("\nWyniki dla metody Eulera:")
for i, (xi, yi) in enumerate(zip(x_euler, y_euler), 1):
    print(f"y_{i-1}({xi:.3f}) = {yi:.5f}")

print("\nWyniki dla metody punktu środkowego:")
for i, (xi, yi) in enumerate(zip(x_midpoint, y_midpoint), 1):
    print(f"y_{i-1}({xi:.3f}) = {yi:.5f}")

print("\nWyniki dla rozwiązania dokładnego (y=x^2):")
for i, (xi, yi) in enumerate(zip(x_analytic, x_analytic**2), 1):
    print(f"y_{i-1}({xi:.3f}) = {yi:.5f}")

print(f"\nBłąd maksymalny dla metody Eulera: {error_euler}")
print(f"Błąd maksymalny dla metody punktu środkowego: {error_midpoint}")